# -*- coding: utf-8 -*-

# Sub program to handle table in UI handling table frame
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import random
from PyQt5.QtCore import *
from PyQt5.QtGui import *
import numpy as np
import time
import py_hid

###########################################################################################################
# Table Prepare
###########################################################################################################
class TableModel(QAbstractTableModel):
    # Color set of table
    color_min = ['#990000', '#CC0000', '#FF0000', '#FF3333', '#FF6666', '#FF9999', '#FFCCCC']
    color_zero = '#FFFFFF'
    color_pos = ['#CCFFCC', '#99FF99', '#66FF66', '#33FF33', '#00FF00', '#00CC00', '#009900']

    def __init__(self, data):
        super(TableModel, self).__init__()
        self._data = data

    def data(self, index, role):
        # If Display Active
        if role == Qt.DisplayRole:
            return self._data[index.row()][index.column()]

        # If Background Color Active / Has been set
        if role == Qt.BackgroundRole:
            value = self._data[index.row()][index.column()]
            if (value >= -32769 and value < -28400):
                return QColor(self.color_min[0])
            elif (value >= -28400 and value < -24031):
                return QColor(self.color_min[1])
            elif (value >= -24031 and value < -19662):
                return QColor(self.color_min[2])
            elif (value >= -19662 and value < -15293):
                return QColor(self.color_min[3])
            elif (value >= -15293 and value < -10924):
                return QColor(self.color_min[4])
            elif (value >= -10924 and value < -6555):
                return QColor(self.color_min[5])
            elif (value >= -6555 and value < -2186):
                return QColor(self.color_min[6])

            elif (value >= -2186 and value < 2183):
                return QColor(self.color_zero)

            elif (value >= 2183 and value < 6552):
                return QColor(self.color_pos[0])
            elif (value >= 6552 and value < 10921):
                return QColor(self.color_pos[1])
            elif (value >= 10921 and value < 15290):
                return QColor(self.color_pos[2])
            elif (value >= 15290 and value < 19659):
                return QColor(self.color_pos[3])
            elif (value >= 19659 and value < 24028):
                return QColor(self.color_pos[4])
            elif (value >= 24028 and value < 28397):
                return QColor(self.color_pos[5])
            elif (value >= 28397):
                return QColor(self.color_pos[6])

    def rowCount(self, index):
        # Overwrite function
        return len(self._data)

    def columnCount(self, index):
        # Overwrite function
        return len(self._data[0])

###########################################################################################################
# QT Main
###########################################################################################################
def table_start(ui) -> None : ...
def table_stop(ui) -> None : ...
def loop_table(ui, max_row: int, max_column: int) -> None : ...


def table_start(ui): # real signature unknown; start the table
    # Setting the UI
    ui.table_working = 1
    ui.xAxisInput_table.setDisabled(True)
    ui.yAxisInput_table.setDisabled(True)
    ui.tableRunButton.setText("Stop")

def table_stop(ui): # real signature unknown; stop the table
    # Setting the UI
    ui.table_working = 0
    ui.tableRunButton.setText("Start")
    ui.xAxisInput_table.setDisabled(False)
    ui.yAxisInput_table.setDisabled(False)

def loop_table(ui, max_row, max_column): # real signature unknown; update  the table value
    # Prepare variable for data
    data_table = []

    # Generate random value
    for i in range(max_row):
        data_table.append([random.randint(0, 20) for j in range(max_column)])

    print(data_table)

    # Make model from ui.data_table
    model = TableModel(data_table)
    # Set model to ui.tableView
    ui.tableView.setModel(model)

    # Change column size
    for i in range(max_column):
        ui.tableView.horizontalHeader().resizeSection(i, 50)

def update_table(ui, max_row, max_column): # real signature unknown; update  the table value
    arr = [random.randint(0, 256) for j in range(max_column*max_row*2)]
    print(arr)

    # Prepare variable for data
    data_table = []

    # Generate random value

    idx = 0
    count_row = -1

    while (count_row < max_row):
        if idx % (2 * max_column) == 0:
        #if idx % max_column == 0:
            count_row += 1
            #data_table.append([arr[idx]])
            data_table.append([int.from_bytes(arr[idx:idx + 2], "little")])
        else:
            #data_table[count_row].append(arr[idx])
            data_table[count_row].append(int.from_bytes(arr[idx:idx + 2], "little"))

        idx += 2
        #idx+=1

        if idx == len(arr):
            if (len(data_table[count_row]) < max_column):
                while (len(data_table[count_row]) < max_column):
                    data_table[count_row].append(111)
            break

    print(data_table)

    # Make model from ui.data_table
    model = TableModel(data_table)
    # Set model to ui.tableView
    ui.tableView.setModel(model)

    # Change column size
    for i in range(max_column):
        ui.tableView.horizontalHeader().resizeSection(i, 50)

def update_table1(ui, max_row, max_column, value1): # real signature unknown; update  the table value
    # Prepare variable for data
    data_table = []

    # Generate random value

    idx = 0
    count_row = -1

    while (count_row < max_row):
        value = int.from_bytes(value1[idx:idx+2], "little")
        if value > 32767:
            value -= 65536
        if idx%(2*max_column)==0:
            count_row += 1
            if (count_row == max_row):
                break
            data_table.append([value])
        else:
            data_table[count_row].append(value)

        idx+=2

        if idx==len(value1):
            if(len(data_table[count_row]) < max_column):
                while (len(data_table[count_row]) < max_column):
                    data_table[count_row].append(111)
            break

    #print(data_table)

    # Make model from ui.data_table
    model = TableModel(data_table)
    # Set model to ui.tableView
    ui.tableView.setModel(model)

    # Change column size
    for i in range(max_column):
        ui.tableView.horizontalHeader().resizeSection(i, 80)

def get_value_MCU(ui, sendRepetition):
    """

    :param ui:
    :param sendRepetition: start from 1 to 10
    :return:
    """
    time.sleep(0.01)  # Wait
    py_hid.send_to_mcu_by_usb(ui, 10+sendRepetition)
    time.sleep(0.01)  # Wait
    data = ui.device.read(65)

    while (len(data) <= 0):
        continue

    if (len(data) > 0):
        data = data[2:]
        return data

    return data

def get_value_all_MCU(ui):
    """
    :param ui:
    :return:
    """
    data = []

    for i in range (10):
        arr = get_value_MCU(ui, i+1)

        for j in range (len(arr)):
            data.append(arr[j])

    return data