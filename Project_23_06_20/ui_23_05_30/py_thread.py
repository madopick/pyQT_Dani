# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'pyqt.ui'
# UI for Program_23_05_26 for communication with UART and I2C
# UI for Program_23_05_30 for communication with USB
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import sys, os, serial, serial.tools.list_ports, warnings
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import QColor
import time
from PyQt5.QtWidgets import *
from PyQt5.uic import loadUi
from PyQt5.QtGui import QIntValidator
import serial.tools.list_ports as port_list

import hid
import datetime, threading

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.pyplot as plt



import py_table_frame as tbl
import py_plot_frame as plot
import py_hid
import py_button_react as br

USB_VENDOR  = 0x0483
USB_PRODUCT = 0x5750

result = []
portindex = 0

str_cfg_header = [
    "{WB1:", "{WB2:", "{WB3:",
    "{RBA}",
	"{RD0}",
	"{RB1}", "{RB2}", "{RB3}",
]


###########################################################################################################
# Serial Port Checks
###########################################################################################################
def serial_ports():
    global portindex

    if sys.platform.startswith('win'):
        ports = ['COM%s' % (i + 1) for i in range(256)]
    elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
        # this excludes your current terminal "/dev/tty"
        ports = glob.glob('/dev/tty[A-Za-z]*')
    elif sys.platform.startswith('darwin'):
        ports = glob.glob('/dev/tty.*')
    else:
        raise EnvironmentError('Unsupported platform')

    for port in ports:
        try:
            s = serial.Serial(port)
            s.close()
            result.append(port)
        except (OSError, serial.SerialException):
            pass

    ports = list(port_list.comports())
    for p in ports:
        if "STLink" in str(p):
            break
        else:
            portindex += 1
    return result


###########################################################################################################
# UART RX Thread.
###########################################################################################################
class Worker(QObject):
    finished = pyqtSignal()
    byteReady = pyqtSignal(list)

    @pyqtSlot()
    def __init__(self):
        super(Worker, self).__init__()
        self.working = True

    def work_byte(self):
        while self.working:
            if ser.isOpen():
                line = ser.read(122)        # Setting length of byte data
            else:
                line = b''

            if line != b'':
                time.sleep(0.1)
                databyte = list(line)
                self.byteReady.emit(databyte)

        self.finished.emit()

###########################################################################################################
# Convert integer to byte(2)
###########################################################################################################
def integer_to_byte(num):
    data = [0, 0]
    if (num > 0):
        data = [(num % 256), int(num / 256) % 128]
    elif (num < 0):
        temp = abs(num) - 1
        data = [255 - (temp % 256), 128 - int(temp / 256) % 128 + 127]

    return data

###########################################################################################################
# QT Main
###########################################################################################################
class qt(QMainWindow):

    def __init__(self):
        QMainWindow.__init__(self)
        loadUi('ui.ui', self)

        self.thread = None
        self.worker = None
        self.pushBtnClicked = False
        self.CopyFlag = 0
        self.ConnectStatus = 0
        self.Port = "UART"
        self.getAll = 0
        self.sendAll = 0
        self.data = [[],
                     [],
                     [],
                     []]
        self.numberInput = 10
        self.next_call = 0
        self.usb_working = 0
        self.device = 0
        self.usb_task = 0  # 0 = nothing to do         1 = read continously the data from stm      2 = write some command to stm
        self.plot_working = 0
        self.table_working = 0

        ###########################################################################################################
        # Variable for table
        ###########################################################################################################
        self.plot_maxValueX = 16
        self.plot_maxValueY = 16
        self.plot_limit_history = 10


        self.max_column_table = 16
        self.max_row_table = 18
        self.data_table = []

        onlyInt = QIntValidator()
        onlyInt.setRange(-2147483640, 2147483640)

        ############################################################################################################
        ### HEADER AND CONNECT SERIAL#
        self.connectButton.clicked.connect(self.start_loop)
        self.openButton.clicked.connect(self.open_file)

        self.generalCmd1SendButton.clicked.connect(self.sendCmd1)
        self.generalCmd1ClearButton.clicked.connect(self.clearCmd1)

        self.generalCmd2SendButton.clicked.connect(self.sendCmd2)
        self.generalCmd2ClearButton.clicked.connect(self.clearCmd2)
        ### HEADER AND CONNECT SERIAL ### END
        ############################################################################################################
        ### INPUT FRAME
        self.input1 = [self.input1_1,self.input1_2,self.input1_3,self.input1_4,self.input1_5,
                       self.input1_6,self.input1_7,self.input1_8,self.input1_9,self.input1_10]
        self.writeButton1.clicked.connect(self.write1)
        self.readButton1.clicked.connect(self.read1)

        self.input2 = [self.input2_1,self.input2_2,self.input2_3,self.input2_4,self.input2_5,
                       self.input2_6,self.input2_7,self.input2_8,self.input2_9,self.input2_10]
        self.writeButton2.clicked.connect(self.write2)
        self.readButton2.clicked.connect(self.read2)

        self.input3 = [self.input3_1,self.input3_2,self.input3_3,self.input3_4,self.input3_5,
                       self.input3_6,self.input3_7,self.input3_8,self.input3_9,self.input3_10]
        self.writeButton3.clicked.connect(self.write3)
        self.readButton3.clicked.connect(self.read3)

        for i in range(self.numberInput):
            self.input1[i].setValidator(onlyInt)
            self.input2[i].setValidator(onlyInt)
            self.input3[i].setValidator(onlyInt)

        ### INPUT FRAME ### END
        ############################################################################################################
        ### OUTPUT FRAME
        self.sendAllButton.clicked.connect(self.writeAll)
        self.readAllButton.clicked.connect(self.readAll)
        self.clearAllConfigButton.clicked.connect(self.clear2)

        self.readBuffer.clicked.connect(self.read0)
        self.clearButton.clicked.connect(self.clear)
        self.saveOption.addItems(["TXT", "CSV", "XLSX"])
        self.saveButton.clicked.connect(self.save)
        ### OUTPUT FRAME ### END
        ############################################################################################################
        ### Plot Frame
        self.historyInput.addItems(["10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"])
        self.fingerInput.addItems(["3", "4", "5", "6", "7", "8", "9", "10"])
        self.plotRunButton.clicked.connect(self.plotChangeStatus)
        ############################################################################################################
        ### Table Frame
        self.xAxisInput_table.setText(str(self.max_column_table))
        self.yAxisInput_table.setText(str(self.max_row_table))

        self.tableRunButton.clicked.connect(self.tableChangeStatus)

        for i in range(self.max_row_table):
            self.data_table.append([0 for j in range (self.max_column_table)])

        self.model = tbl.TableModel(self.data_table)
        self.tableView.setModel(self.model)

        # Change column size
        for i in range (self.max_column_table):
            self.tableView.horizontalHeader().resizeSection(i, 80)
        ############################################################################################################

        # global result
        print("Available ports:" + str(serial_ports()))
        for x in range(len(result)):
            name = result[x]
            self.cb_Port.addItem(name)
        self.cb_Port.addItem("USB")

    ###########################################################################################################
    # Loop
    ###########################################################################################################
    def stop_loop(self):
        self.worker.working = False
        ser.close()

    def start_loop(self):
        global ser

        #Disconnect
        if(self.ConnectStatus == 1):
            self.ConnectStatus = 0
            self.connectButton.setText("Connect")
            self.status_value.setText("Not Connected")
            self.openButton.setDisabled(True)

            if (self.Port == "UART"):
                self.stop_loop()
            else:
                self.usb_working = 0
                self.device.close()
            return

        #Verify the correct COM Port
        try:
            self.openButton.setDisabled(False)
            mytext = "{RBA}\r\n"  # Send first enter

            self.getAll = 1

            if (self.cb_Port.currentText() == "USB"):
                print("USB HID Communication")
                self.Port = "USB"
            else:
                self.Port = "UART"
                ser = serial.Serial(self.cb_Port.currentText(),
                                    115200, timeout=1)
                ser.write(mytext.encode())

            if (self.ConnectStatus == 0):
                self.ConnectStatus = 1
                self.connectButton.setText("Disconnect")

        except:
            msgBox = QMessageBox()
            msgBox.setWindowTitle("COM Port Error!")
            msgBox.setIcon(QMessageBox.Warning)
            msgBox.setText("Selected COM port does not exist. Please verify the COM port Number.")
            msgBox.exec()
            return

        if (self.Port == "UART"):
            QToolTip.setFont(QFont('Arial', 7))
            self.generalCmd1.setToolTip("Command:\n"
                                        "'{WB1:',  '{WB2:',  '{WB3:',  '{RBA}',\n'{RD0}',  '{RB1}',  '{RB2}',  '{RB3}'")
            self.generalCmd2.setToolTip("Command:\n"
                                        "'{WB1:',  '{WB2:',  '{WB3:',  '{RBA}',\n'{RD0}',  '{RB1}',  '{RB2}',  '{RB3}'")

            self.worker = Worker()
            self.thread = QThread()
            self.worker.moveToThread(self.thread)

            self.thread.started.connect(self.worker.work_byte)
            self.worker.byteReady.connect(self.onByteReady)

            self.worker.finished.connect(self.thread.quit)
            self.worker.finished.connect(self.worker.deleteLater)
            self.thread.finished.connect(self.thread.deleteLater)
            self.thread.start()
            self.status_value.setText("Connected to Serial")

        else:
            print("USB Thread here")

            QToolTip.setFont(QFont('Arial', 7))
            self.generalCmd1.setToolTip("Command:\n"
                                        "'{RND}',\n"
                                        "'{RD1}' used for generate random many times,\n"
                                        "'{RD2}' used for generate random once time,\n"
                                        "'{SRD}' used for stop generate number for MCU, not GUI")
            self.generalCmd2.setToolTip("Command:\n"
                                        "'{RND}',\n"
                                        "'{RD1}' used for generate random many times,\n"
                                        "'{RD2}' used for generate random once time,\n"
                                        "'{SRD}' used for stop generate number for MCU, not GUI")

            try:
                self.device = hid.device()
                self.device.open(0x0483, 0x5750)  # DONGLE VendorID/ProductID
                print("Manufacturer: %s" % self.device.get_manufacturer_string())
                print("Product: %s" % self.device.get_product_string())
                print("Serial No: %s" % self.device.get_serial_number_string())

                # enable non-blocking mode
                self.device.set_nonblocking(1)

                self.usb_working = 1

                timerThread = threading.Thread(target=self.hid_usb_handler)
                timerThread.daemon = True
                timerThread.start()
                self.connectButton.setText("Disconnect")
                self.status_value.setText("Connected to USB")

            except:
                self.connectButton.setText("Connect")
                self.status_value.setText("Not Connected")
                msgBox = QMessageBox()
                msgBox.setWindowTitle("USB Not Connected!")
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("USB does not connected. Please check the USB connection.")
                msgBox.exec()
                return

    ###########################################################################################################
    # USB HID Data handler.
    ###########################################################################################################
    def hid_usb_handler(self):
        """
        Loop when program connect to USB. At this program, command only can give at command form, not from any button
        :return:
        """
        self.next_call = time.time()
        while self.usb_working:
            time.sleep(0.1)
            if ((self.usb_task == 1) or (self.usb_task == 2)):
                #print(datetime.datetime.now())
                self.next_call = self.next_call + 1

                if self.usb_task == 1:          # Start infinite loop to send trigger and get static data from MCU  CMD: {RD1}
                    py_hid.send_to_mcu_by_usb(self, 22)
                    py_hid.read_from_mcu_by_usb_config(self)

                if (self.usb_task == 2):        # Send trigger and get random data from MCU                         CMD: {RD2}
                    py_hid.send_to_mcu_by_usb(self, 23)
                    py_hid.read_from_mcu_by_usb_config(self)

                    py_hid.usb_change_signal(self, 0)

            if (self.usb_task == 6):                                                                                # CMD: {SRD}
                py_hid.send_to_mcu_by_usb(self, 24)
                py_hid.usb_change_signal(self, 0)

            if (self.usb_task == 3):
                self.send_to_mcu_by_usb(8)
                time.sleep(0.1)  # Wait

                #self.usb_data = self.device.read(65)
                self.usb_data = py_hid.read_from_mcu_by_usb(self)

                plot.updatePlot(ui=self, plot_maxValueX=self.plot_maxValueX,
                                 plot_limit_history=self.plot_limit_history,
                                 value=self.usb_data, finger=self.finger)
                time.sleep(0.1)  # Wait
                self.usb_task = 5

            if (self.usb_task == 5):
                self.send_to_mcu_by_usb(9)
                time.sleep(0.1)  # Wait

                #self.usb_data = self.device.read(65)
                self.usb_data = py_hid.read_from_mcu_by_usb(self)

                plot.updatePlot(ui=self, plot_maxValueX=self.plot_maxValueX,
                                plot_limit_history=self.plot_limit_history,
                                value=self.usb_data, finger=self.finger)
                time.sleep(0.1)  # Wait

            if (self.usb_task == 4):
                data = tbl.get_value_all_MCU(self)

                tbl.update_table1(self, self.max_row_table, self.max_column_table, data)

    def onByteReady(self, data):
        int_val = []
        #print(data)

        global line

        if (self.getAll == 1):
            arr_show = []
            for x in range(0, 10):
                start = (x * 2) + 2
                end = start + 2
                res = int.from_bytes(data[start:end], "little")
                if res > 32767:
                    res = res - 65536
                arr_show.append(res)

            self.output.setText("")

        start_poin = 0
        if data[0] != 16 and data[1] != 17:
            for i in range(len(data)):
                if (data[i] == 13 and data[i + 1] == 10):
                    temp2 = data[start_poin:i]
                    start_poin = i + 2
                    if (temp2[0] == 20 and temp2[1] == 21):
                        string = ''.join(map(chr, temp2[2:len(temp2) + 2]))
                        self.output.append("{}".format(string))
                        if ((temp2[2] == 66 and temp2[3] == 117) and (
                                (temp2[9] == 68 and temp2[10] == 105) or (temp2[9] == 115 and temp2[10] == 97))):
                            self.output.append("{}".format("\r\n"))
                    if (temp2[0] == 18 and temp2[1] == 19):
                        arr = []
                        for x in range(0, 10):
                            strt = (x * 2) + 2
                            end = strt + 2
                            res = int.from_bytes(temp2[strt:end], "little")
                            if res > 32767:
                                res = res - 65536
                            arr.append(res)
                        self.output.append("{}".format(arr))
                        self.output.append("{}".format("\r\n"))

        if data[0] == 16 and data[1] == 17:  # {RBA}
            if (self.getAll == 1):
                for x in range(0, 81):
                    start = (x * 2) + 2
                    end = start + 2
                    res = int.from_bytes(data[start:end], "little")
                    if res > 32767:
                        res = res - 65536
                    int_val.append(res)

                for i in range(10):
                    self.input1[i].setText(str(int_val[i]))
                    self.input2[i].setText(str(int_val[i + 10]))
                    self.input3[i].setText(str(int_val[i + 20]))

                self.getAll = 0

        if data[0] == 16 and data[1] == 18:
            self.output.append("All value already change!!\r\n")

    def clear(self):
        """
        To clear all output history
        :return:
        """
        br.clear_output_history(self)

    def clear2(self):
        """
        To clear all input config
        :return:
        """
        br.clear_input_config(self)

    def clearCmd1(self):
        """
        To clear command 1
        :return:
        """
        self.generalCmd1.setText('')

    def clearCmd2(self):
        """
        To clear command 2
        :return:
        """
        self.generalCmd2.setText('')

    ###########################################################################################################
    ### Save Format
    ###########################################################################################################
    def save(self):
        """
        To save output history as .txt file or config as .csv or .excel file
        :return:
        """
        if (self.saveOption.currentText() == "TXT"):        # import save_output_history_as_txt from py_button_react
            br.save_output_history_as_txt(self, self.output.toPlainText())

        elif (self.saveOption.currentText()=="CSV"):        # import save_form_as_csv from py_button_react
            br.save_form_as_csv(self)

        elif (self.saveOption.currentText()=="XLSX"):       # import save_form_as_excel from py_button_react
            br.save_form_as_excel(self)

    def open_file(self):
        """
        To open file external from csv or excel and put it in to config
        :return:
        """
        # Popup dialog box to show save folder target
        fileName, _ = QFileDialog.getOpenFileName(filter="CSV (*.csv *.tsv *.xlsx)")
        filter = fileName[fileName.find("."):len(fileName)]

        if fileName and filter==".csv":     # import open_csv from py_button_react
            br.open_csv(self, fileName)

        if fileName and filter==".xlsx":    # import open_excel from py_button_react
            br.open_excel(self, fileName)

    def write1(self):
        """
        Send values of config 1 to MCU by serial
        :return:
        """
        # I mport serial_send_config from py_button_react
        br.serial_send_config(self, header=[123, 87, 66, 49, 58],  # header = {WB1:
                              config=self.input1, status="Write to serial WR1", serial=ser)


    def write2(self):
        """
        Send values of config 2 to MCU by serial
        :return:
        """
        # I mport serial_send_config from py_button_react
        br.serial_send_config(self, header=[123, 87, 66, 50, 58],  # header = {WB2:
                              config=self.input2, status="Write to serial WR2", serial=ser)

    def write3(self):
        """
        Send values of config 3 to MCU by serial
        :return:
        """
        # I mport serial_send_config from py_button_react
        br.serial_send_config(self, header = [123, 87, 66, 51, 58],         # header = {WB3:
                              config = self.input3, status = "Write to serial WR3", serial = ser)

    def writeAll(self):
        br.serial_send_all_config(ui = self, config1 = self.input1, config2 = self.input2,
                                  config3 = self.input3, status = "Write to serial All", serial = ser)

    def sendCmd(self, text):
        mytext_ascii = text
        mytext_byte = []
        find = False

        if self.usb_working:            # When USB connected
            self.usb_task = 0
            if (mytext_ascii[0:5] == "{USB:"):          # Send data to MCU
                if (mytext_ascii.find(";") < 0):  # catch error when input doesn't use ";" separate
                    msgBox = QMessageBox()
                    msgBox.setWindowTitle("Command False")
                    msgBox.setIcon(QMessageBox.Warning)
                    msgBox.setText("Write command must be write as example!!\n"
                                   "{USB:1;2;3;4;5;6;7;8;9;10}")
                    msgBox.exec()
                    return
                else:
                    mytext_byte = py_hid.prep_usb(self, mytext_ascii = text)        # Import prep_usb from py_hid to manage the input


                    self.device.write(mytext_byte)

            elif (mytext_ascii[0:5] == "{RD1}"):        # Ask MCU to send static value to program
                py_hid.usb_change_signal(self, 1)
            elif (mytext_ascii[0:5] == "{RD2}"):        # Ask MCU to send random value to program
                py_hid.usb_change_signal(self, 2)
            elif (mytext_ascii[0:5] == "{SRD}"):
                py_hid.usb_change_signal(self, 6)      # Stop Random generate for MCU

        else:
            for i in range(len(str_cfg_header)):
                if (mytext_ascii[0:5] == str_cfg_header[i]):
                    for j in range(5):
                        mytext_byte.append(ord(mytext_ascii[j]))

                    if i < 3:
                        mytext_ascii = mytext_ascii[5:len(mytext_ascii)]
                        sparatePosition = mytext_ascii.find(";")
                        if (sparatePosition == -1):

                            msgBox.setText("Write command must be write as example!!\n"
                                           "{WB1:1;2;3;4;5;6;7;8;9;10}")
                            msgBox.exec()
                            return
                        else:
                            count_data = 0
                            while count_data < self.numberInput:
                                sparatePosition = mytext_ascii.find(";")
                                if i == 0:
                                    self.input1[count_data].setText(mytext_ascii[0:sparatePosition])
                                elif i == 1:
                                    self.input2[count_data].setText(mytext_ascii[0:sparatePosition])
                                elif i == 2:
                                    self.input3[count_data].setText(mytext_ascii[0:sparatePosition])
                                data = integer_to_byte(int(mytext_ascii[0:sparatePosition]))
                                for j in range(2):
                                    mytext_byte.append(data[j])
                                mytext_ascii = mytext_ascii[sparatePosition + 1:len(mytext_ascii)]
                                count_data += 1
                            sparatePosition = mytext_ascii.find("}")
                            if i == 0:
                                self.input1[count_data].setText(mytext_ascii[0:sparatePosition])
                            elif i == 1:
                                self.input2[count_data].setText(mytext_ascii[0:sparatePosition])
                            elif i == 2:
                                self.input3[count_data].setText(mytext_ascii[0:sparatePosition])
                            data = integer_to_byte(int(mytext_ascii[0:sparatePosition]))
                            for j in range(2):
                                mytext_byte.append(data[j])


                    mytext_byte.append(13)
                    mytext_byte.append(10)

                    find = True

            if (find == False):
                msgBox.setText("Wrong command given!!\n"
                               "Command:\n"
                               "'{WB1:','{WB2:','{WB3:','{RBA}','{RD0}','{RB1}','{RB2}','{RB3}'")
                msgBox.exec()
                return
            else:
                ser.write(mytext_byte)

    def sendCmd1(self):
        self.sendCmd(self.generalCmd1.text())

    def sendCmd2(self):
        self.sendCmd(self.generalCmd2.text())

    def read0(self):
        br.serial_send(self, [123, 82, 68, 48, 125, 13, 10], ser, "Write to serial {RD0}")  # {RD0}\r\n

    def readAll(self):          # Only read from input place and used when you want to save to .xlxs or .csv
        for i in range(3):
            mytext = "R{}: {}; ".format(i + 1, i + 1)
            for j in range(self.numberInput):
                if (i == 0):
                    mytext += "{}".format(self.input1[j].text())
                elif (i == 1):
                    mytext += "{}".format(self.input2[j].text())
                elif (i == 2):
                    mytext += "{}".format(self.input3[j].text())

                if (j < self.numberInput - 1):
                    mytext += "; "
                else:
                    mytext += "\n"
            self.output.append(mytext)

    def read1(self):
        br.serial_send(self, [123, 82, 66, 49, 125, 13, 10], "Write to serial RD1", ser)  # {RB1}\r\n

    def read2(self):
        br.serial_send(self, [123, 82, 66, 50, 125, 13, 10], "Write to serial RD2", ser)  # {RB2}\r\n

    def read3(self):
        br.serial_send(self, [123, 82, 66, 51, 125, 13, 10], "Write to serial RD3", ser)  # {RB3}\r\n

    ###########################################################################################################
    ### Plot Setting
    ###########################################################################################################
    def plotChangeStatus(self):
        """
        Turn on or turn off plot connectivity
        :return:
        """
        if (self.usb_working and self.plot_working == 0):
            self.plot_maxValueX = int(self.xAxisInput.text())
            self.plot_maxValueY = int(self.yAxisInput.text())
            self.plot_limit_history = int(self.historyInput.currentText())
            self.finger = int(self.fingerInput.currentText())

            self.tableRunButton.setDisabled(True)
            self.xAxisInput_table.setDisabled(True)
            self.yAxisInput_table.setDisabled(True)

            plot.plot_start(ui=self, plot_maxValueX=self.plot_maxValueX, plot_maxValueY=self.plot_maxValueY)
            py_hid.usb_change_signal(self, 3)
            self.plot_working = 1
        elif (self.usb_working and self.plot_working):
            self.send_to_mcu_by_usb(9)
            plot.plot_stop(self)

            self.tableRunButton.setDisabled(False)
            self.xAxisInput_table.setDisabled(False)
            self.yAxisInput_table.setDisabled(False)

            py_hid.usb_change_signal(self, 0)
            self.plot_working = 0
        else:
            return


    ###########################################################################################################
    ### Table Setting
    ###########################################################################################################
    def tableChangeStatus(self):
        """
        Turn on or turn off table connectivity
        :return:
        """
        if (int(self.xAxisInput_table.text())>16 or int(self.xAxisInput_table.text())<5):
            msgBox = QMessageBox()
            msgBox.setWindowTitle("Warning!")
            msgBox.setIcon(QMessageBox.Warning)
            msgBox.setText("X axis must between 5 to 16.")
            msgBox.exec()
            return
        elif (int(self.yAxisInput_table.text())>18 or int(self.yAxisInput_table.text())<5):
            msgBox = QMessageBox()
            msgBox.setWindowTitle("Warning!")
            msgBox.setIcon(QMessageBox.Warning)
            msgBox.setText("Y axis must between 5 to 18.")
            msgBox.exec()
            return
        else:
            if (self.usb_working and self.table_working == 0):
                self.max_row_table = int(self.yAxisInput_table.text())
                self.max_column_table = int(self.xAxisInput_table.text())

                tbl.table_start(self)
                self.plotRunButton.setDisabled(True)
                self.xAxisInput.setDisabled(True)
                self.yAxisInput.setDisabled(True)
                self.historyInput.setDisabled(True)
                self.fingerInput.setDisabled(True)

                py_hid.usb_change_signal(self, 4)
                self.table_working = 1
            elif (self.usb_working and self.table_working):
                self.send_to_mcu_by_usb(9)
                tbl.table_stop(self)
                self.plotRunButton.setDisabled(False)
                self.xAxisInput.setDisabled(False)
                self.yAxisInput.setDisabled(False)
                self.historyInput.setDisabled(False)
                self.fingerInput.setDisabled(False)

                py_hid.usb_change_signal(self, 0)
                self.table_working = 0
            else:
                return

    def send_to_mcu_by_usb(self, signal):
        """
        Transmit by USB
        :param signal: The code to trigger transmit by USB
        0 : {WBA}
        1 : {WB1}
        2 : {WB2}
        3 : {WB3}
        4 : {RBA}
        5 : {RB1}
        6 : {RB2}
        7 : {RB3}
        8 : Start Infinite Loop Plot
        9 : Stop Infinite Loop Plot
        10 : Generate 1 Random Table1
        11 : Generate 1 Random Table2
        12 : Loop the USB
        :return:
        """
        py_hid.send_to_mcu_by_usb(self, signal)






##################################################################################################
# QT RUN
##################################################################################################
def run():
    app = QApplication(sys.argv)
    widget = qt()
    widget.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    run()


